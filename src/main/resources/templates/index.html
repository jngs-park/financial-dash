<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <title>Financial Dash</title>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>

    <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; padding: 16px; margin: 0; }
    .row { display:flex; gap:12px; align-items:baseline; flex-wrap:wrap; margin-bottom:10px; }
    .badge { padding:6px 10px; border-radius:999px; background:#f2f2f2; font-size:14px; }
    .chart-wrap { max-width:980px; width:100%; height:420px; position:relative; }
    canvas { width:100% !important; height:100% !important; display:block; }
    #debug { margin-top:10px; white-space:pre-wrap; font-family:ui-monospace,SFMono-Regular,Menlo,monospace;
             font-size:12px; background:#0b1020; color:#d6e1ff; padding:10px; border-radius:8px; max-width:980px; }
  </style>
</head>
<body>

<div class="row">
    <h2 style="margin:0;">KRW-BTC Price History</h2>
    <div class="badge" id="trendBadge">Trend: -</div>
    <div class="badge" id="lastBadge">Last: -</div>
</div>

<div class="chart-wrap">
    <canvas id="priceChart"></canvas>
</div>

<div id="debug">Loading...</div>

<script>
  const MARKET = "KRW-BTC";
  const HISTORY_URL = `/api/market/upbit/history?market=${MARKET}`;
  const STREAM_URL  = `/api/market/upbit/stream?market=${MARKET}`;

  const WINDOW_MIN = 10;              // 최근 10분만 표시
  const MA_SHORT = 5;
  const MA_LONG  = 20;

  let chart;
  let points = []; // [{x: Date, y: number}]

  /* ================= utils ================= */

  function formatKST(d) {
    return d.toLocaleTimeString("ko-KR", { hour12: false });
  }
  function formatKRW(n) {
    return Number(n).toLocaleString("ko-KR");
  }
  function setDebug(lines) {
    document.getElementById("debug").textContent = lines.join("\n");
  }

  function movingAverage(srcPoints, window) {
    return srcPoints.map((p, i) => {
      if (i < window - 1) return { x: p.x, y: null };
      const slice = srcPoints.slice(i - window + 1, i + 1);
      const avg = slice.reduce((s, v) => s + v.y, 0) / window;
      return { x: p.x, y: avg };
    });
  }

  function trimWindow() {
    const now = Date.now();
    const min = now - WINDOW_MIN * 60 * 1000;
    points = points.filter(p => p.x.getTime() >= min);
    return { now, min };
  }

  /* ================= chart ================= */

  function ensureChart() {
    const ctx = document.getElementById("priceChart").getContext("2d");
    chart = new Chart(ctx, {
      type: "line",
      data: {
        datasets: [
          {
            label: "BTC Price",
            data: [],
            parsing: false,
            pointRadius: 0,
            borderWidth: 2,
            tension: 0.2,
            borderColor: "#22c55e" // 초록(잘 보임)
          },
          {
            label: "MA5",
            data: [],
            parsing: false,
            pointRadius: 0,
            borderWidth: 1.5,
            borderColor: "#f59e0b" // 주황
          },
          {
            label: "MA20",
            data: [],
            parsing: false,
            pointRadius: 0,
            borderWidth: 1.5,
            borderColor: "#3b82f6" // 파랑
          }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        animation: false,
        scales: {
          x: {
            type: "time",
            time: { unit: "second", displayFormats: { second: "HH:mm:ss" } },
            ticks: { maxTicksLimit: 8 }
          },
          y: { beginAtZero: false }
        }
      }
    });
  }

  function render() {
    const { now, min } = trimWindow();

    chart.options.scales.x.min = min;
    chart.options.scales.x.max = now;

    chart.data.datasets[0].data = points;
    chart.data.datasets[1].data = movingAverage(points, MA_SHORT);
    chart.data.datasets[2].data = movingAverage(points, MA_LONG);

    chart.update("none");

    if (points.length === 0) return;

    const last = points.at(-1);
    document.getElementById("lastBadge").textContent =
      `Last: ${formatKRW(last.y)} (${formatKST(last.x)})`;

    const first = points.at(0);
    const pct = ((last.y - first.y) / first.y) * 100;
    const dir = pct > 0 ? "↑ 상승" : "↓ 하락";
    document.getElementById("trendBadge").textContent =
      `Trend: ${dir} (${pct.toFixed(3)}%)`;
  }

  /* ================= init: history then SSE ================= */

  async function loadInitialHistory() {
    const debug = [];
    debug.push(`Initial fetch: ${HISTORY_URL}`);

    const res = await fetch(HISTORY_URL, { cache: "no-store" });
    const raw = await res.text();
    debug.push(`HTTP ${res.status}`);

    if (!res.ok) {
      debug.push(raw.slice(0, 200));
      setDebug(debug);
      return;
    }

    const list = JSON.parse(raw);
    const arr = Array.isArray(list) ? list : [];

    points = arr
      .map(p => {
        const t = p.createdAt ?? p.fetchedAt;
        return { x: new Date(t), y: Number(p.price) };
      })
      .filter(p => p.x.toString() !== "Invalid Date" && !isNaN(p.y));

    debug.push(`Loaded history points: ${points.length}`);
    setDebug(debug);

    render();
  }

  function startSse() {
    const debug = [];
    debug.push(`SSE connect: ${STREAM_URL}`);
    setDebug(debug);

    const es = new EventSource(STREAM_URL);

    es.addEventListener("ping", (e) => {
      setDebug([`SSE connected (ping): ${e.data}`]);
    });

    es.addEventListener("tick", (e) => {
      // tick: { market, price, createdAt }
      const tick = JSON.parse(e.data);
      const x = new Date(tick.createdAt);
      const y = Number(tick.price);

      if (x.toString() === "Invalid Date" || isNaN(y)) return;

      points.push({ x, y });
      render();

      setDebug([
        `SSE OK`,
        `tick market=${tick.market}`,
        `tick price=${formatKRW(y)}`,
        `tick time=${formatKST(x)}`,
        `points in window=${points.length}`
      ]);
    });

    es.onerror = () => {
      setDebug([`SSE error - 연결이 끊겼거나 서버가 내려갔을 수 있음`]);
      // 브라우저가 자동 재연결 시도함
    };
  }

  // boot
  ensureChart();
  loadInitialHistory().then(startSse);
</script>

</body>
</html>